#include "stdafx.h"
#include "cEcosystemCreaturesCache.h"
#include "Spore-Mod-Utils/Include/SporeModUtils.h"

using namespace Simulator;
using namespace SporeModUtils;

/// AUTOGENERATED METHODS ///

int cEcosystemCreaturesCache::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEcosystemCreaturesCache::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEcosystemCreaturesCache::GetName() const {
	return "Ai_Empire_Expansion::cEcosystemCreaturesCache";
}

bool cEcosystemCreaturesCache::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEcosystemCreaturesCache::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cEcosystemCreaturesCache::WriteToXML(XmlSerializer*)
{
	return true;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEcosystemCreaturesCache::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEcosystemCreaturesCache* cEcosystemCreaturesCache::instance = nullptr;

void cEcosystemCreaturesCache::Initialize() {
	instance = this;
	cacheReady = false;
	cycleInterval = 60000;
	cacheSize = 50;
	nextElementToReturn = nullptr;
	nextElementToRefresh = nullptr;
	elapsedTime = 0;
	
}

void cEcosystemCreaturesCache::Dispose() {
	
}

void cEcosystemCreaturesCache::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval && cacheReady) {
			RefreshElement();
			elapsedTime = 0;
		}
	}
}

void cEcosystemCreaturesCache::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		cachedEcosystemCreatures.clear();
		PrepareCache();
		cacheReady = true;
		elapsedTime = 0;
	}

}

void cEcosystemCreaturesCache::OnModeExited(uint32_t previousModeID, uint32_t newModeID) {
	if (previousModeID == GameModeIDs::kGameSpace) {
		cacheReady = false;
		cachedEcosystemCreatures.clear();
		nextElementToReturn = nullptr;
		nextElementToRefresh = nullptr;
	}
}

cEcosystemCreaturesCache* cEcosystemCreaturesCache::Get() {
	return instance;
}

void cEcosystemCreaturesCache::PrepareCache() {
	eastl::vector<ResourceKey> emptyVector;
	for (int i = 0; i < cacheSize; i++) {
		eastl::vector<ResourceKey> ecosystemCreatures;
		CALL(Address(ModAPI::ChooseAddress(0x00BABC40, 0x00BACE60)), void, Args(Simulator::cStarManager*, eastl::vector<ResourceKey>*, int, int, int, int, eastl::vector<ResourceKey>*),
			Args(Simulator::cStarManager::Get(), &emptyVector, 3, 2, 2, 1, &ecosystemCreatures));
		cachedEcosystemCreatures.push_back(ecosystemCreatures);
	}
	nextElementToReturn = cachedEcosystemCreatures.begin();
	nextElementToRefresh = cachedEcosystemCreatures.begin();
}

void cEcosystemCreaturesCache::RefreshElement() {
	nextElementToRefresh->clear();
	eastl::vector<ResourceKey> emptyVector;
	cacheReady = false;
	CALL(Address(ModAPI::ChooseAddress(0x00BABC40, 0x00BACE60)), void, Args(Simulator::cStarManager*, eastl::vector<ResourceKey>*, int, int, int, int, eastl::vector<ResourceKey>*),
		Args(Simulator::cStarManager::Get(), &emptyVector, 3, 2, 2, 1, nextElementToRefresh));
	cacheReady = true;
	++nextElementToRefresh;
	if (nextElementToRefresh == cachedEcosystemCreatures.end()) {
		nextElementToRefresh = cachedEcosystemCreatures.begin();
	}
}

eastl::vector<ResourceKey>* cEcosystemCreaturesCache::ReturnElement() {
	if (cacheReady) {
		eastl::vector<ResourceKey>* element = nextElementToReturn;
		++nextElementToReturn;
		if (nextElementToReturn == cachedEcosystemCreatures.end()) {
			nextElementToReturn = cachedEcosystemCreatures.begin();
		}
		return element;
	}
	else {
		return nullptr;
	}
}