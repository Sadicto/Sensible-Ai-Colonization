#include "stdafx.h"
#include "cEmpireColonizationManager.h"
#include <algorithm>

/// AUTOGENERATED METHODS ///

int cEmpireColonizationManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireColonizationManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireColonizationManager::GetName() const {
	return "AiEmpireExpansion::cEmpireColonizationManager";
}

bool cEmpireColonizationManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireColonizationManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cEmpireColonizationManager::WriteToXML(XmlSerializer*)
{
	return true;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireColonizationManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEmpireColonizationManagerPtr cEmpireColonizationManager::instance = nullptr;

void cEmpireColonizationManager::Initialize() {
	instance = cEmpireColonizationManagerPtr(this);

	eastl::vector<ResourceKey> speedConfigs;

	PropertyListPtr propList;

	PropManager.GetPropertyList(id("Config"), id("SaicConfig"), propList);
	
	// General configuration.

	App::Property::GetFloat(propList.get(), 0x676FDB24, activeRadius);

	App::Property::GetInt32(propList.get(), 0x964CF55A, cycleInterval);

	App::Property::GetFloat(propList.get(), 0x98199E80, targetNumSystems);

	App::Property::GetInt32(propList.get(), 0xD226209D, levelToColonizeTribe);

	App::Property::GetInt32(propList.get(), 0xBEE4774B, levelToColonizeCiv);

	App::Property::GetArrayFloat(propList.get(), 0xDFC93C59, colonizationRange);

	App::Property::GetArrayKey(propList.get(), 0x5A2D3987, speedConfigs);

	// Speed configuration.
	bool found = false;
	for (ResourceKey const &key : speedConfigs) {
		found = PropManager.GetPropertyList(key.instanceID, key.groupID, propList);
		if (found) { // Only one speedConfig was installed; we just have to find out which one it is.
			break;
		}
	}
	if (found) {
		App::Property::GetFloat(propList.get(), 0x79288FD9, cyclesToTargetColonies);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	elapsedTime = 0;

	//idk if there´s a better way to do this lol.
	eastl::string16 stringRed(u"spice1");
	ResourceKey::Parse(redSpice, stringRed.c_str());

	eastl::string16 stringYellow(u"spice3");
	ResourceKey::Parse(yellowSpice, stringYellow.c_str());

	eastl::string16 stringBlue(u"spice2");
	ResourceKey::Parse(blueSpice, stringBlue.c_str());

	eastl::string16 stringGreen(u"spice4");
	ResourceKey::Parse(greenSpice, stringGreen.c_str());

	eastl::string16 stringPink(u"spice5");
	ResourceKey::Parse(pinkSpice, stringPink.c_str());

	eastl::string16 stringPurple(u"spice6");
	ResourceKey::Parse(purpleSpice, stringPurple.c_str());
	
	ResourceKey::Parse(adventureIconKey, u"0x0199b485!0x881aeb0a.0x2f7d0004");
}

void cEmpireColonizationManager::Dispose() {
	
}

void cEmpireColonizationManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			EmpiresExpansionCycle();
			elapsedTime = 0;
		}
	}
}

void cEmpireColonizationManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {

		// Cleanup of the mess of the 1.0.0.
		eastl::vector<int> field = StarManager.field_3C;
		eastl::vector<cStar*>& starVector = *reinterpret_cast<eastl::vector<cStar*>*>(&field);
		for (auto it = starVector.begin(); it != starVector.end(); ) {
			cStar* star = *it;
			if (star->mpStarRecord == nullptr) {
				star->mpStarRecord = StarManager.GetStarRecord(0);
				//GameNounManager.DestroyInstance(star);
				//it = starVector.erase(it);
			}
			else {
				++it;
			}
		}
		elapsedTime = 0;
	}
	cStrategy::OnModeEntered(previousModeID, newModeID); //idk if it is necessary.
}

cEmpireColonizationManagerPtr cEmpireColonizationManager::Get() {
	return instance;
}

bool cEmpireColonizationManager::ColonizablePlanet(cPlanetRecord* planet) { //TODO 201planet.
	PlanetType type = planet->mType;
	return ((type == PlanetType::T3 ||
		type == PlanetType::T2 ||
		type == PlanetType::T1 ||
		type == PlanetType::T0) &&
		(cPlanetRecord::GetTypeIconKey(planet) != adventureIconKey && //not adventure, idk if there's a better way to do this
		!planet->IsDestroyed()));
}

float cEmpireColonizationManager::PlanetColonizationScore(cPlanetRecord* planet) {
    float score = 1;
	//if habitable, more terrascore more points.
    if (planet->mType == PlanetType::T3 || 
        planet->mType == PlanetType::T2 ||
        planet->mType == PlanetType::T1) {
        score = score + (static_cast<float>(planet->mType) * 10);
    }
	//if T0, green orbit more points.
    else { 
        if (((planet->mFlags & kPlanetFlagRedOrbit) == 0) &&
            ((planet->mFlags & kPlanetFlagBlueOrbit) == 0)) {
            score = score + 10;
        }
    }
	//moon.
    if (planet->IsMoon()) {
        score = score / 2;
    }

    ResourceKey spiceGen = planet->mSpiceGen;

    if (spiceGen == redSpice) {
        score++;
    }
    else if (spiceGen == yellowSpice) {
        score = score + 3;
    }
    else if (spiceGen == blueSpice) {
        score = score + 4;
    }
    else if (spiceGen == greenSpice) {
        score = score + 6;
    }
    else if (spiceGen == pinkSpice) {
        score = score + 8;
    }
    else if (spiceGen == purpleSpice) {
        score = score + 10;
    }
    return score;
}

bool cEmpireColonizationManager::ColonizableStar(cStarRecord* star) { 

	StarType type = star->GetType();
	//a star, unclaimed, no monolith, not savegme, not Sol and near the player.
	if (
		type != StarType::GalacticCore &&
		type != StarType::BlackHole &&
		type != StarType::ProtoPlanetary &&
		star->GetTechLevel() != TechLevel::Empire &&
		(star->mFlags & (1 << 3)) == 0 && //no monolith
		(star->mFlags & (1 << 1)) == 0 && //no savegame
		star != StarManager.GetSol() &&
		GetDistanceBetweenStars(GetActiveStarRecord(), star) < activeRadius) {

		//at least one planet is colonizable.
		for (cPlanetRecordPtr planet : star->GetPlanetRecords()) {
			if (ColonizablePlanet(planet.get())){
				return (true);
			}
		}
	}
	return false;
}

bool cEmpireColonizationManager::EmpireCanColonizeStar(cEmpire* empire, cStarRecord* star){
	TechLevel techLevel = star->GetTechLevel();
	int empireLevel = GetEmpireLevel(empire);

	return ColonizableStar(star) 
		&& (techLevel == TechLevel::None || techLevel == TechLevel::Creature
		|| (techLevel == TechLevel::Tribe && empireLevel >= levelToColonizeTribe)
		|| (techLevel == TechLevel::Civilization && empireLevel >= levelToColonizeCiv));
}


cPlanetRecordPtr cEmpireColonizationManager::BestColonizablePlanet(cStarRecord* star) {
	//first filter all the non colonizable planets.
	eastl::vector<cPlanetRecordPtr> colonizablePlanets;

	for (cPlanetRecordPtr planet : star->GetPlanetRecords()) {
		if (ColonizablePlanet(planet.get())) {
			colonizablePlanets.push_back(planet); 
		}
	}

	cPlanetRecordPtr bestPlanet = colonizablePlanets.front();
	float bestScore = PlanetColonizationScore(bestPlanet.get());
	colonizablePlanets.erase(colonizablePlanets.begin());

	//choose the best planet.
	for (cPlanetRecordPtr planet : colonizablePlanets) {
		float planetScore = PlanetColonizationScore(planet.get());
		if (planetScore > bestScore) {
			bestPlanet = planet;
			bestScore = planetScore;
		}
	}
	return bestPlanet;
}

float cEmpireColonizationManager::StarColonizationScore(cStarRecord* star) {
	float score = PlanetColonizationScore(BestColonizablePlanet(star).get());

	if (star->GetTechLevel() == TechLevel::Tribe) {
		score = score / 5;
	}
	else if (star->GetTechLevel() == TechLevel::Civilization) {
		score = score / 20;
	}
	return score;
}

void  cEmpireColonizationManager::DeleteTribeFromStar(cStarRecord* star) {
	star->mTechLevel = TechLevel::Creature;
	star->mCitizenSpeciesKey.instanceID = 0;
	star->mCitizenSpeciesKey.typeID = 0;
	star->mCitizenSpeciesKey.groupID = 0;
	star->mpSpeciesProfile = NULL;

	//find the planet with the tribe and edit it .
	for (cPlanetRecordPtr planet : star->GetPlanetRecords()) {
		if (planet->GetTechLevel() == TechLevel::Tribe) {
			planet->mTechLevel = TechLevel::Creature;
			planet->mTribeData.clear();
		}
		break;
	}
}

void cEmpireColonizationManager::DeleteCivFromStar(cStarRecord* star) {
	star->mTechLevel = TechLevel::Creature;
	star->mCitizenSpeciesKey.instanceID = 0;
	star->mCitizenSpeciesKey.typeID = 0;
	star->mCitizenSpeciesKey.groupID = 0;
	star->mpSpeciesProfile = NULL;

	//find the planet with the civ and edit it. 
	for (cPlanetRecordPtr planet : star->GetPlanetRecords()) {
		if (planet->GetTechLevel() == TechLevel::Civilization) {
			planet->mTechLevel = TechLevel::Creature;
			planet->mCivData.clear();
		}
		break;
	}
}

SolarSystemOrbitTemperature cEmpireColonizationManager::GetPlanetOrbitTemperature(cPlanetRecord* planet){
	if (planet->mFlags & PlanetFlags::kPlanetFlagBlueOrbit) {
		return SolarSystemOrbitTemperature::Cold;
	}
	else if (planet->mFlags & PlanetFlags::kPlanetFlagRedOrbit){
		return SolarSystemOrbitTemperature::Hot;
	}
	else {
		return SolarSystemOrbitTemperature::Normal;
	}
}

bool cEmpireColonizationManager::PlanetCompletePlantEcosystem(cPlanetRecord* planet) {
	PlanetType planetType = planet->mType;
	int plantSpeciesNum = planet->mPlantSpecies.size();
	return (planetType == PlanetType::T0) || 
		(planetType == PlanetType::T1 && plantSpeciesNum == 3)||
		(planetType == PlanetType::T2 && plantSpeciesNum == 6)||
		(planetType == PlanetType::T3 && plantSpeciesNum == 9);
}

bool cEmpireColonizationManager::PlanetCompleteAnimalEcosystem(cPlanetRecord* planet) {
	PlanetType planetType = planet->mType;
	int animalSpeciesNum = planet->mAnimalSpecies.size();
	return (planetType == PlanetType::T0) || 
		(planetType == PlanetType::T1 && animalSpeciesNum == 3) ||
		(planetType == PlanetType::T2 && animalSpeciesNum == 6) ||
		(planetType == PlanetType::T3 && animalSpeciesNum == 9);
}

bool cEmpireColonizationManager::PlanetCompleteEcosystem(cPlanetRecord* planet) {
	return PlanetCompletePlantEcosystem(planet) && PlanetCompleteAnimalEcosystem(planet);
}

void cEmpireColonizationManager::FillPlanetPlants(cPlanetRecord* planet) {
	if ((planet->mType == PlanetType::T3 ||
		planet->mType == PlanetType::T2 ||
		planet->mType == PlanetType::T1) &&
		!PlanetCompletePlantEcosystem(planet)) {
		ResourceKey terrainScript = planet->GetGeneratedTerrainKey();
		eastl::vector<ResourceKey> scriptPlants;
		StarManager.GetPlantsByTerrainScript(&terrainScript, &scriptPlants);

		int planetTerrascore = static_cast<int>(planet->mType) - 2;
		StarManager.GeneratePlanetPlants(&scriptPlants, planetTerrascore, planetTerrascore - 1, 3, 0, &planet->mPlantSpecies);
	}
}

void cEmpireColonizationManager::FillPlanetCreatures(cPlanetRecord* planet) {
	if ((planet->mType == PlanetType::T3 ||
		planet->mType == PlanetType::T2 ||
		planet->mType == PlanetType::T1) &&
		!PlanetCompleteAnimalEcosystem(planet)) {

		int planetTerrascore = static_cast<int>(planet->mType) - 2;
		eastl::vector<ResourceKey> priorityCreatures; // empty, we don't care about specific creatures.
		StarManager.GeneratePlanetCreatures(&priorityCreatures, planetTerrascore, planetTerrascore - 1, 2, 1, &planet->mAnimalSpecies);
	}
}

void cEmpireColonizationManager::FillPlanetEcosystem(cPlanetRecord* planet) {
	if (!PlanetCompletePlantEcosystem(planet)) {
		FillPlanetPlants(planet);
	}
	if (!PlanetCompleteAnimalEcosystem(planet)) {
		FillPlanetCreatures(planet);
	}
}

void cEmpireColonizationManager::GeneratePlanets(cStarRecord* star) {
	eastl::vector<cPlanetRecordPtr> planets = star->GetPlanetRecords();
	cStar* starT = simulator_new<cStar>();
	starT->mpStarRecord = star;
	starT->GetSolarSystem();
	GameNounManager.DestroyInstance(starT);
	cPlanetRecordPtr planetToColonize = BestColonizablePlanet(star);
	if (!PlanetCompleteEcosystem(planetToColonize.get())) {
		FillPlanetEcosystem(planetToColonize.get());
	}
}

void cEmpireColonizationManager::ColonizeStarSystem(cEmpire* empire, cStarRecord* star) {
	cPlanetRecordPtr planet = BestColonizablePlanet(star);
	uint32_t empireId = empire->GetEmpireID();

	empire->AddStarOwnership(star);
	star->mTechLevel = TechLevel::Empire;
	star->mEmpireID = empireId;

	planet->mTechLevel = TechLevel::Empire;
	cPlanetRecord::FillPlanetDataForTechLevel(planet.get(), TechLevel::Empire);
	for (auto civData : planet->mCivData) {
		civData->mPoliticalID = empireId;
	}
}

void cEmpireColonizationManager::GetEmpiresInRadius(const Vector3& coords, float radius, eastl::vector<cEmpirePtr>& empires) {
	StarRequestFilter filter;
	filter.RemoveStarType(StarType::None);
	filter.RemoveStarType(StarType::GalacticCore);
	filter.RemoveStarType(StarType::ProtoPlanetary);
	filter.RemoveStarType(StarType::BlackHole);
	filter.techLevels = 0;
	filter.AddTechLevel(TechLevel::Empire);
	filter.minDistance = 0;
	filter.maxDistance = radius;

	eastl::vector<cStarRecordPtr> starsColonized;
	StarManager.FindStars(coords, filter, starsColonized);

	// Set prevents duplicates.
	eastl::set<uint32_t> empireIDSet; 

	uint32_t groxEmpireID = StarManager.GetGrobEmpireID();

	// Collect unique mEmpireID owners of the stars, except the grox, the player empire and other saves empires.
	for (cStarRecordPtr star : starsColonized) {
		cEmpire* starEmpire = StarManager.GetEmpire(star->mEmpireID);
		if(starEmpire != nullptr && 
			starEmpire != GetPlayerEmpire() && 
			starEmpire->GetEmpireID() != groxEmpireID && 
			(starEmpire->mFlags & (1 << 6)) == 0) /* no empire from other save.*/{
			empireIDSet.insert(starEmpire->GetEmpireID());
		}
	}
	// Get the empire for every id.
	for (uint32_t id : empireIDSet) {
		empires.push_back(cEmpirePtr(StarManager.GetEmpire(id)));
	}
}

void cEmpireColonizationManager::GetUnclaimedStarsInRadius(const Vector3& coords, float radius, eastl::vector<cStarRecordPtr>& stars) {
	StarRequestFilter filter;
	filter.RemoveStarType(StarType::None);
	filter.RemoveStarType(StarType::GalacticCore);
	filter.RemoveStarType(StarType::ProtoPlanetary);
	filter.RemoveStarType(StarType::BlackHole);
	filter.techLevels = 0;

	//even stars with all planet in T0 have this techLevel
	filter.AddTechLevel(TechLevel::Creature); 

	//we don't care about tribes or civilizations
	filter.AddTechLevel(TechLevel::Tribe);
	filter.AddTechLevel(TechLevel::Civilization);

	filter.minDistance = 0;
	filter.maxDistance = radius;
	cStarManager* starManager = cStarManager::Get();
	starManager->FindStars(coords, filter, stars);
}

float cEmpireColonizationManager::GetDistanceBetweenStars(cStarRecord* star1, cStarRecord* star2) {
	return (star1->mPosition - star2->mPosition).Length();
}

int cEmpireColonizationManager::GetEmpireLevel(cEmpire* empire) { // TODO read prop with the power levels and calculate it that way.
	int numSystems = empire->mStars.size();
	if (numSystems <= 3) {
		return 0;
	}
	else if (numSystems <= 5) {
		return 1;
	}
	else if (numSystems <= 8) {
		return 2;
	}
	else if (numSystems <= 12) {
		return 3;
	}
	else {
		return 4;
	}
}

void cEmpireColonizationManager::ExpandEmpire(cEmpire* empire) {
	cStarRecord* homeworld = empire->GetHomeStarRecord();
	float range = colonizationRange[GetEmpireLevel(empire)];
	eastl::vector<cStarRecordPtr> empireStars = empire->mStars;
	cStarRecordPtr candidateStar = NULL;

	// Scores for each nearby colonizable star; the star with the highest score will be colonized.
	eastl::map<cStarRecordPtr, float> starScores;

	// Find all colonizable stars within nearStarRadius from each empireStar and calculate their score.
	for (cStarRecordPtr empireStar : empireStars) {

		eastl::vector<cStarRecordPtr> nearUnclaimedStars;
		GetUnclaimedStarsInRadius(empireStar->mPosition, range, nearUnclaimedStars);
		for (cStarRecordPtr nearbyStar : nearUnclaimedStars) {
			// Planets are needed in each candidate star for the algorithm to function properly.
			StarManager.RequirePlanetsForStar(nearbyStar.get());

			// Check if the star is colonizable and the player is not currently in it.
			if (EmpireCanColonizeStar(empire, nearbyStar.get()) && nearbyStar.get() != GetActiveStarRecord()) {
				// If the star is not in the map, add it and calculate its base score.
				if (starScores.count(nearbyStar) == 0) {
					// The further the star is from the homeworld, the lower the score.
					starScores[nearbyStar] = StarColonizationScore(nearbyStar.get()) / (GetDistanceBetweenStars(homeworld, nearbyStar.get()) * 2);
				}
				else {
					// If the star is already in the map, it means it's close to multiple stars, so increase its score.
					starScores[nearbyStar] *= 2;
				}
			}
		}
		float maxScore = -1;
		// find the Star with the highest Score.
		for (const auto& pair : starScores) {
			if (pair.second > maxScore) {
				maxScore = pair.second;
				candidateStar = pair.first;
			}
		}
	}
	// If candidateStar is NULL, then there isn't a nearby colonizable star, so the empire does not expand.
	if (candidateStar != NULL) {
		if (candidateStar->GetTechLevel() == TechLevel::Tribe) {
			DeleteTribeFromStar(candidateStar.get());
		}
		else if (candidateStar->GetTechLevel() == TechLevel::Civilization) {
			DeleteCivFromStar(candidateStar.get());
		}
		GeneratePlanets(candidateStar.get());
		ColonizeStarSystem(empire, candidateStar.get());
	}
}

float cEmpireColonizationManager::EmpireColonizationProbability(cEmpire* empire) {
	return targetNumSystems / cyclesToTargetColonies;
}

void cEmpireColonizationManager::EmpiresExpansionCycle() {
	// Only empires within activeRadius parsecs can expand.
	eastl::vector <cEmpirePtr> nearEmpires;

	GetEmpiresInRadius(GetActiveStarRecord()->mPosition, activeRadius, nearEmpires);
	// For each nearby empire, calculate pOfExpansion and expand it based on the probability.
	for (cEmpirePtr empire : nearEmpires) {
		float pOfExpansion = EmpireColonizationProbability(empire.get());
		float n = Math::randf();
		if (pOfExpansion > n) {
			ExpandEmpire(empire.get());
		}
	}
}




