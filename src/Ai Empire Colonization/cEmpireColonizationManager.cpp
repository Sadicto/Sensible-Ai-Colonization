#include "stdafx.h"
#include "cEmpireColonizationManager.h"
#include <algorithm>
#include "Spore-Mod-Utils/Include/SporeModUtils.h"

/// AUTOGENERATED METHODS ///

int cEmpireColonizationManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireColonizationManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireColonizationManager::GetName() const {
	return "AiEmpireExpansion::cEmpireColonizationManager";
}

bool cEmpireColonizationManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireColonizationManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cEmpireColonizationManager::WriteToXML(XmlSerializer*)
{
	return true;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireColonizationManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEmpireColonizationManagerPtr cEmpireColonizationManager::instance = nullptr;

void cEmpireColonizationManager::Initialize() {
	instance = cEmpireColonizationManagerPtr(this);

	ResourceKey speedConfigKey;

	ResourceKey intraSystemColonizationKey;

	PropertyListPtr generalConfiguration;

	PropManager.GetPropertyList(id("Config"), id("SaicConfig"), generalConfiguration);
	
	// General configuration.

	App::Property::GetFloat(generalConfiguration.get(), 0x676FDB24, activeRadius);

	App::Property::GetInt32(generalConfiguration.get(), 0x964CF55A, cycleInterval);

	App::Property::GetFloat(generalConfiguration.get(), 0x98199E80, targetNumSystems);

	App::Property::GetInt32(generalConfiguration.get(), 0xD226209D, levelToColonizeTribe);

	App::Property::GetInt32(generalConfiguration.get(), 0xBEE4774B, levelToColonizeCiv);

	App::Property::GetArrayFloat(generalConfiguration.get(), 0xDFC93C59, colonizationRange);

	App::Property::GetKey(generalConfiguration.get(), 0x7176E6BC, speedConfigKey);

	App::Property::GetKey(generalConfiguration.get(), 0x21EC8183, intraSystemColonizationKey);

	// Speed configuration.
	PropertyListPtr speedConfiguration;
	bool found = PropManager.GetPropertyList(speedConfigKey.instanceID, speedConfigKey.groupID, speedConfiguration);
	if (found) {
		App::Property::GetFloat(speedConfiguration.get(), 0x79288FD9, cyclesToTargetColonies);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	// Intra system planet colonization configuration.
	PropertyListPtr intraSystemConfiguration;
	found = PropManager.GetPropertyList(intraSystemColonizationKey.instanceID, intraSystemColonizationKey.groupID, intraSystemConfiguration);
	if (found) {
		App::Property::GetBool(intraSystemConfiguration.get(), 0x1FEB9478, enableIntraSystemColonization);
		App::Property::GetBool(intraSystemConfiguration.get(), 0x21BD71B0, excludeT0PlanetColonization);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	elapsedTime = 0;

	//idk if there´s a better way to do this lol.
	eastl::string16 stringRed(u"spice1");
	ResourceKey::Parse(redSpice, stringRed.c_str());

	eastl::string16 stringYellow(u"spice3");
	ResourceKey::Parse(yellowSpice, stringYellow.c_str());

	eastl::string16 stringBlue(u"spice2");
	ResourceKey::Parse(blueSpice, stringBlue.c_str());

	eastl::string16 stringGreen(u"spice4");
	ResourceKey::Parse(greenSpice, stringGreen.c_str());

	eastl::string16 stringPink(u"spice5");
	ResourceKey::Parse(pinkSpice, stringPink.c_str());

	eastl::string16 stringPurple(u"spice6");
	ResourceKey::Parse(purpleSpice, stringPurple.c_str());
	
}

void cEmpireColonizationManager::Dispose() {
	
}

void cEmpireColonizationManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			EmpiresExpansionCycle();
			elapsedTime = 0;
		}
	}
}

void cEmpireColonizationManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {

		// Cleanup of the mess of the 1.0.0.
		eastl::vector<int> field = StarManager.field_3C;
		eastl::vector<cStar*>& starVector = *reinterpret_cast<eastl::vector<cStar*>*>(&field);
		for (auto it = starVector.begin(); it != starVector.end(); ) {
			cStar* star = *it;
			if (star->mpStarRecord == nullptr) {
				star->mpStarRecord = StarManager.GetStarRecord(0);
				//GameNounManager.DestroyInstance(star);
				//it = starVector.erase(it);
			}
			else {
				++it;
			}
		}
		elapsedTime = 0;
	}
	cStrategy::OnModeEntered(previousModeID, newModeID); //idk if it is necessary.
}

cEmpireColonizationManagerPtr cEmpireColonizationManager::Get() {
	return instance;
}

float cEmpireColonizationManager::PlanetColonizationScore(cPlanetRecord* planet) {
    float score = 1;
	//if habitable, more terrascore more points.
    if (planet->mType == PlanetType::T3 || 
        planet->mType == PlanetType::T2 ||
        planet->mType == PlanetType::T1) {
        score = score + (static_cast<float>(planet->mType) * 10);
    }
	//if T0, green orbit more points.
    else { 
        if (((planet->mFlags & kPlanetFlagRedOrbit) == 0) &&
            ((planet->mFlags & kPlanetFlagBlueOrbit) == 0)) {
            score = score + 10;
        }
    }

    if (planet->IsMoon()) {
        score = score / 2;
    }

    ResourceKey spiceGen = planet->mSpiceGen;

    if (spiceGen == redSpice) {
        score++;
    }
    else if (spiceGen == yellowSpice) {
        score = score + 3;
    }
    else if (spiceGen == blueSpice) {
        score = score + 4;
    }
    else if (spiceGen == greenSpice) {
        score = score + 6;
    }
    else if (spiceGen == pinkSpice) {
        score = score + 8;
    }
    else if (spiceGen == purpleSpice) {
        score = score + 10;
    }
    return score;
}

bool cEmpireColonizationManager::ColonizableStar(cStarRecord* star) { 

	StarType type = star->GetType();
	//a star, unclaimed, no monolith, not savegme, not Sol and near the player.
	if (
		type != StarType::GalacticCore &&
		type != StarType::BlackHole &&
		type != StarType::ProtoPlanetary &&
		star->GetTechLevel() != TechLevel::Empire &&
		(star->mFlags & (1 << 3)) == 0 && //no monolith
		(star->mFlags & (1 << 1)) == 0 && //no savegame
		star != StarManager.GetSol() &&
		StarUtils::GetDistanceBetweenStars(GetActiveStarRecord(), star) < activeRadius) {

		//at least one planet is colonizable.
		for (cPlanetRecordPtr planet : star->GetPlanetRecords()) {
			if (PlanetUtils::InteractablePlanet(planet.get())){
				return (true);
			}
		}
	}
	return false;
}

bool cEmpireColonizationManager::EmpireCanColonizeStar(cEmpire* empire, cStarRecord* star){
	TechLevel techLevel = star->GetTechLevel();
	int empireLevel = EmpireUtils::GetEmpireLevel(empire);

	return ColonizableStar(star) 
		&& (techLevel == TechLevel::None || techLevel == TechLevel::Creature
		|| (techLevel == TechLevel::Tribe && empireLevel >= levelToColonizeTribe)
		|| (techLevel == TechLevel::Civilization && empireLevel >= levelToColonizeCiv));
}


cPlanetRecordPtr cEmpireColonizationManager::BestColonizablePlanet(cStarRecord* star) {
	//first filter all the non colonizable planets.
	eastl::vector<cPlanetRecordPtr> colonizablePlanets;

	for (cPlanetRecordPtr planet : star->GetPlanetRecords()) {
		if (PlanetUtils::InteractablePlanet(planet.get())) {
			colonizablePlanets.push_back(planet); 
		}
	}

	cPlanetRecordPtr bestPlanet = colonizablePlanets.front();
	float bestScore = PlanetColonizationScore(bestPlanet.get());
	colonizablePlanets.erase(colonizablePlanets.begin());

	//choose the best planet.
	for (cPlanetRecordPtr planet : colonizablePlanets) {
		float planetScore = PlanetColonizationScore(planet.get());
		if (planetScore > bestScore) {
			bestPlanet = planet;
			bestScore = planetScore;
		}
	}
	return bestPlanet;
}

void cEmpireColonizationManager::ColonizePlanet(cEmpire* empire, cPlanetRecord* planet) {
	if (!PlanetUtils::PlanetHasCompleteEcosystem(planet)) {
		PlanetUtils::FillPlanetEcosystem(planet);
	}
	planet->mTechLevel = TechLevel::Empire;
	cPlanetRecord::FillPlanetDataForTechLevel(planet, TechLevel::Empire);
	for (auto civData : planet->mCivData) {
		civData->mPoliticalID = empire->GetEmpireID();
	}

}

float cEmpireColonizationManager::StarColonizationScore(cStarRecord* star) {
	float score = PlanetColonizationScore(BestColonizablePlanet(star).get());

	if (star->GetTechLevel() == TechLevel::Tribe) {
		score = score / 5;
	}
	else if (star->GetTechLevel() == TechLevel::Civilization) {
		score = score / 20;
	}
	return score;
}

void cEmpireColonizationManager::ColonizeStarSystem(cEmpire* empire, cStarRecord* star) {
	
	empire->AddStarOwnership(star);
	star->mTechLevel = TechLevel::Empire;
	star->mEmpireID = empire->GetEmpireID();;
	cPlanetRecordPtr planet = BestColonizablePlanet(star);
	ColonizePlanet(empire, planet.get());
}

void cEmpireColonizationManager::ColonizePlanetInOwnedSystem(cEmpire* empire) {
	eastl::vector<cPlanetRecordPtr> planets;
	EmpireUtils::GetEmpirePlanets(empire, planets, true, false, false, false, excludeT0PlanetColonization);
	// Find the planet with the best colonization score.
	auto it = eastl::max_element(planets.begin(), planets.end(),
		[this](const cPlanetRecordPtr& a, const cPlanetRecordPtr& b) {
			return PlanetColonizationScore(a.get()) < PlanetColonizationScore(b.get());
		});
	if (it != planets.end() && it->get() != GetActivePlanetRecord()) {
		ColonizePlanet(empire, it->get());
	}
}

void cEmpireColonizationManager::ExpandEmpire(cEmpire* empire) {
	cStarRecord* homeworld = empire->GetHomeStarRecord();
	float range = colonizationRange[EmpireUtils::GetEmpireLevel(empire)];
	eastl::vector<cStarRecordPtr> empireStars = empire->mStars;
	cStarRecordPtr candidateStar = NULL;

	// Scores for each nearby colonizable star; the star with the highest score will be colonized.
	eastl::map<cStarRecordPtr, float> starScores;

	// Find all colonizable stars within nearStarRadius from each empireStar and calculate their score.
	for (cStarRecordPtr empireStar : empireStars) {

		eastl::vector<cStarRecordPtr> nearUnclaimedStars;
		StarUtils::GetUnclaimedStarsInRadius(empireStar->mPosition, range, nearUnclaimedStars, true, true);
		for (cStarRecordPtr nearbyStar : nearUnclaimedStars) {
			// Planets are needed in each candidate star for the algorithm to function properly.
			StarManager.RequirePlanetsForStar(nearbyStar.get());

			// Check if the star is colonizable and the player is not currently in it.
			if (EmpireCanColonizeStar(empire, nearbyStar.get()) && nearbyStar.get() != GetActiveStarRecord()) {
				// If the star is not in the map, add it and calculate its base score.
				if (starScores.count(nearbyStar) == 0) {
					// The further the star is from the homeworld, the lower the score.
					starScores[nearbyStar] = StarColonizationScore(nearbyStar.get()) / (StarUtils::GetDistanceBetweenStars(homeworld, nearbyStar.get()) * 2);
				}
				else {
					// If the star is already in the map, it means it's close to multiple stars, so increase its score.
					starScores[nearbyStar] *= 2;
				}
			}
		}
		float maxScore = -1;
		// find the Star with the highest Score.
		for (const auto& pair : starScores) {
			if (pair.second > maxScore) {
				maxScore = pair.second;
				candidateStar = pair.first;
			}
		}
	}
	// If candidateStar is NULL, then there isn't a nearby colonizable star.
	if (candidateStar != NULL) {
		if (candidateStar->GetTechLevel() == TechLevel::Tribe) {
			StarUtils::DeleteTribeFromStar(candidateStar.get());
		}
		else if (candidateStar->GetTechLevel() == TechLevel::Civilization) {
			StarUtils::DeleteCivFromStar(candidateStar.get());
		}
		StarUtils::GeneratePlanets(candidateStar.get());
		ColonizeStarSystem(empire, candidateStar.get());
	}
	else if (enableIntraSystemColonization) {
		ColonizePlanetInOwnedSystem(empire);
	}
}

float cEmpireColonizationManager::EmpireColonizationProbability(cEmpire* empire) {
	return targetNumSystems / cyclesToTargetColonies;
}

void cEmpireColonizationManager::EmpiresExpansionCycle() {
	// Only empires within activeRadius parsecs can expand.
	eastl::vector <cEmpirePtr> nearEmpires;

	EmpireUtils::GetEmpiresInRadius(GetActiveStarRecord()->mPosition, activeRadius, nearEmpires);
	// For each nearby empire, calculate pOfExpansion and expand it based on the probability.
	for (cEmpirePtr empire : nearEmpires) {
		float pOfExpansion = EmpireColonizationProbability(empire.get());
		float n = Math::randf();
		if (pOfExpansion > n) {
			ExpandEmpire(empire.get());
		}
	}
}




