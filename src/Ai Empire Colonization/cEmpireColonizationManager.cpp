#include "stdafx.h"
#include "cEmpireColonizationManager.h"
#include <algorithm>
#include "Spore-Mod-Utils/Include/SporeModUtils.h"

using namespace SporeModUtils;
/// AUTOGENERATED METHODS ///

int cEmpireColonizationManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireColonizationManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireColonizationManager::GetName() const {
	return "AiEmpireExpansion::cEmpireColonizationManager";
}

bool cEmpireColonizationManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireColonizationManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cEmpireColonizationManager::WriteToXML(XmlSerializer*)
{
	return true;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireColonizationManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEmpireColonizationManager* cEmpireColonizationManager::instance = nullptr;

void cEmpireColonizationManager::Initialize() {
	instance = this;

	ResourceKey speedConfigKey;

	ResourceKey radiusConfigKey;

	ResourceKey intraSystemColonizationKey;

	PropertyListPtr generalConfiguration;

	PropManager.GetPropertyList(id("Config"), id("SaicConfig"), generalConfiguration);
	
	// General configuration.

	App::Property::GetInt32(generalConfiguration.get(), 0x54D3A437, cycleInterval);

	App::Property::GetFloat(generalConfiguration.get(), 0x98199E80, targetNumSystems);

	App::Property::GetInt32(generalConfiguration.get(), 0xD226209D, levelToColonizeTribe);

	App::Property::GetInt32(generalConfiguration.get(), 0xBEE4774B, levelToColonizeCiv);

	App::Property::GetArrayFloat(generalConfiguration.get(), 0xDFC93C59, colonizationRange);

	App::Property::GetKey(generalConfiguration.get(), 0x7176E6BC, speedConfigKey);

	App::Property::GetKey(generalConfiguration.get(), 0x9732887C, radiusConfigKey);

	App::Property::GetKey(generalConfiguration.get(), 0x21EC8183, intraSystemColonizationKey);

	// Speed configuration.
	PropertyListPtr speedConfiguration;
	bool found = PropManager.GetPropertyList(speedConfigKey.instanceID, speedConfigKey.groupID, speedConfiguration);
	if (found) {
		App::Property::GetFloat(speedConfiguration.get(), 0xD092326A, secondsToTargetNumSystems);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	// Radius configuration.
	PropertyListPtr radiusConfiguration;
	found = PropManager.GetPropertyList(radiusConfigKey.instanceID, radiusConfigKey.groupID, radiusConfiguration);
	if (found) {
		App::Property::GetFloat(radiusConfiguration.get(), 0x0D00F9E5, activeRadius);
		App::Property::GetBool(radiusConfiguration.get(), 0x02FB896F, galacticRadius);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	// Intra system planet colonization configuration.
	PropertyListPtr intraSystemConfiguration;
	found = PropManager.GetPropertyList(intraSystemColonizationKey.instanceID, intraSystemColonizationKey.groupID, intraSystemConfiguration);
	if (found) {
		App::Property::GetBool(intraSystemConfiguration.get(), 0x1FEB9478, enableIntraSystemColonization);
		App::Property::GetBool(intraSystemConfiguration.get(), 0x21BD71B0, excludeT0PlanetColonization);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	elapsedTime = 0;

	lastSubcycleTime = 0;

	subcycleStep = 0;
}

void cEmpireColonizationManager::Dispose() {
	
}

void cEmpireColonizationManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		// Start of a cycle.
		if ( elapsedTime > cycleInterval) {
			empires.clear();
			if (galacticRadius) {
				EmpiresMap empiresMap = StarManager.GetEmpires();
				for (const auto& par : empiresMap) {
					if (EmpireUtils::ValidNpcEmpire(par.second.get())) {
						empires.push_back(par.second);
					}
				}
				subcycleStep = 100;
			}
			else {
				EmpireUtils::GetEmpiresInRadius(GetActiveStarRecord()->mPosition, activeRadius, empires);
				subcycleStep = 1000;
			}
			int numEmpires = empires.size();
			empireToExpand = empires.begin();
			int numSubcycles = cycleInterval / subcycleStep;
			// Division rounding up.
			empiresPerSubCycle = (numEmpires + numSubcycles - 1) / (numSubcycles);
			lastSubcycleTime = 0;
			elapsedTime = 0;
		}
		// Start of a subcycle.
		if (elapsedTime > lastSubcycleTime + subcycleStep) {
			while (elapsedTime > lastSubcycleTime) {
				EmpiresExpansionSubcycle();
				lastSubcycleTime += subcycleStep;
			}
		}
	}
}

void cEmpireColonizationManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		spiceCosts.clear();
		SpiceUtils::GetSpawnableSpiceBaseCosts(spiceCosts);
		// Force the first cycle to trigger immediately on the next Update, delete before release.
		elapsedTime = cycleInterval;
		lastSubcycleTime = 9999999;
		subcycleStep = 9999999;
	}
}

cEmpireColonizationManager* cEmpireColonizationManager::Get() {
	return instance;
}

float cEmpireColonizationManager::PlanetColonizationScore(cPlanetRecord* planet) {
    float score = 1;
	//if habitable, more terrascore more points.
    if (planet->mType == PlanetType::T3 || 
        planet->mType == PlanetType::T2 ||
        planet->mType == PlanetType::T1) {
        score = score + (static_cast<float>(planet->mType) * 10);
    }
	//if T0, green orbit more points.
    else { 
        if (PlanetUtils::GetPlanetOrbitTemperature(planet) == SolarSystemOrbitTemperature::Normal) {
            score = score + 10;
        }
    }

    if (planet->IsMoon()) {
        score = score / 2;
    }

	ResourceKey planetSpice = planet->mSpiceGen;
	ResourceKey cheapestSpice = SpiceUtils::GetCheapestSpice(spiceCosts);
	auto itPlanet = spiceCosts.find(planetSpice);
	if (itPlanet != spiceCosts.end()) {
		float planetSpiceValue = static_cast<float>(itPlanet->second);
		auto itCheapest = spiceCosts.find(cheapestSpice);
		if (itCheapest != spiceCosts.end()) {
			float cheapestSpiceValue = static_cast<float>(itCheapest->second);
			score +=  (planetSpiceValue / cheapestSpiceValue) - 1.0f;
		}
	}
	return score;
}

bool cEmpireColonizationManager::ColonizableStar(cStarRecord* star) { 
	return StarUtils::ValidStar(star) && 
		star->GetTechLevel() != TechLevel::Empire;
}

bool cEmpireColonizationManager::EmpireCanColonizeStar(cEmpire* empire, cStarRecord* star){
	TechLevel techLevel = star->GetTechLevel();
	int empireLevel = EmpireUtils::GetEmpireLevel(empire);

	return ColonizableStar(star) 
		&& (techLevel == TechLevel::None || techLevel == TechLevel::Creature
		|| (techLevel == TechLevel::Tribe && empireLevel >= levelToColonizeTribe)
		|| (techLevel == TechLevel::Civilization && empireLevel >= levelToColonizeCiv));
}


cPlanetRecordPtr cEmpireColonizationManager::BestColonizablePlanet(cStarRecord* star) {
	//first filter all the non colonizable planets.
	eastl::vector<cPlanetRecordPtr> colonizablePlanets;

	for (cPlanetRecordPtr planet : star->GetPlanetRecords()) {
		if (PlanetUtils::InteractablePlanet(planet.get())) {
			colonizablePlanets.push_back(planet); 
		}
	}

	cPlanetRecordPtr bestPlanet = colonizablePlanets.front();
	float bestScore = PlanetColonizationScore(bestPlanet.get());
	colonizablePlanets.erase(colonizablePlanets.begin());

	//choose the best planet.
	for (cPlanetRecordPtr planet : colonizablePlanets) {
		float planetScore = PlanetColonizationScore(planet.get());
		if (planetScore > bestScore) {
			bestPlanet = planet;
			bestScore = planetScore;
		}
	}
	return bestPlanet;
}

void cEmpireColonizationManager::ColonizePlanet(cEmpire* empire, cPlanetRecord* planet) {
	if (!PlanetUtils::PlanetHasCompleteEcosystem(planet)) {
		PlanetUtils::FillPlanetEcosystem(planet);
	}
	planet->mTechLevel = TechLevel::Empire;
}

float cEmpireColonizationManager::StarColonizationScore(cStarRecord* star) {
	float score = 1000;

	if (star->GetTechLevel() == TechLevel::Tribe) {
		score = score / 5;
	}
	else if (star->GetTechLevel() == TechLevel::Civilization) {
		score = score / 20;
	}
	return score;
}

void cEmpireColonizationManager::ColonizeStarSystem(cEmpire* empire, cStarRecord* star) {
	
	empire->AddStarOwnership(star);
	star->mTechLevel = TechLevel::Empire;
	star->mEmpireID = empire->GetEmpireID();;
	cPlanetRecordPtr planet = BestColonizablePlanet(star);
	ColonizePlanet(empire, planet.get());
}

void cEmpireColonizationManager::ColonizePlanetInOwnedSystem(cEmpire* empire) {
	eastl::vector<cPlanetRecordPtr> planets;
	EmpireUtils::GetEmpirePlanets(empire, planets, true, false, false, false, excludeT0PlanetColonization);
	// Find the planet with the best colonization score.
	auto it = eastl::max_element(planets.begin(), planets.end(),
		[this](const cPlanetRecordPtr& a, const cPlanetRecordPtr& b) {
			return PlanetColonizationScore(a.get()) < PlanetColonizationScore(b.get());
		});
	if (it != planets.end() && it->get() != GetActivePlanetRecord()) {
		ColonizePlanet(empire, it->get());
	}
}

void cEmpireColonizationManager::ExpandEmpire(cEmpire* empire) {
	cStarRecord* homeworld = empire->GetHomeStarRecord();
	float range = colonizationRange[EmpireUtils::GetEmpireLevel(empire)];
	eastl::vector<cStarRecordPtr> empireStars = empire->mStars;
	cStarRecordPtr candidateStar = NULL;

	// Scores for each nearby colonizable star; the star with the highest score will be colonized.
	eastl::map<cStarRecordPtr, float> starScores;
	// Find all colonizable stars within nearStarRadius from each empireStar and calculate their score.
	for (cStarRecordPtr empireStar : empireStars) {

		eastl::vector<cStarRecordPtr> nearUnclaimedStars;
		
		StarUtils::GetUnclaimedStarsInRadius(empireStar->mPosition, range, nearUnclaimedStars, true, true);
		for (cStarRecordPtr nearbyStar : nearUnclaimedStars) {
			StarManager.RequirePlanetsForStar(nearbyStar.get());
			// Check if the star is colonizable and the player is not currently in it.
			if (EmpireCanColonizeStar(empire, nearbyStar.get()) && nearbyStar.get() != GetActiveStarRecord()) {
				// If the star is not in the map, add it and calculate its base score.
				if (starScores.count(nearbyStar) == 0) {
					// The further the star is from the homeworld, the lower the score.
					starScores[nearbyStar] = StarColonizationScore(nearbyStar.get()) / (StarUtils::GetDistanceBetweenStars(homeworld, nearbyStar.get()) * 2);
				}
				else {
					// If the star is already in the map, it means it's close to multiple stars, so increase its score.
					starScores[nearbyStar] *= 2;
				}
			}
		}
		float maxScore = -1;
		// find the Star with the highest Score.
		for (const auto& pair : starScores) {
			if (pair.second > maxScore) {
				maxScore = pair.second;
				candidateStar = pair.first;
			}
		}
	}
	// If candidateStar is NULL, then there isn't a nearby colonizable star.
	if (candidateStar != NULL) {
		if (candidateStar->GetTechLevel() == TechLevel::Tribe) {
			StarUtils::DeleteTribeFromStar(candidateStar.get());
		}
		else if (candidateStar->GetTechLevel() == TechLevel::Civilization) {
			StarUtils::DeleteCivFromStar(candidateStar.get());
		}
		StarUtils::GeneratePlanets(candidateStar.get());
		ColonizeStarSystem(empire, candidateStar.get());

	}
	else if (enableIntraSystemColonization) {
		ColonizePlanetInOwnedSystem(empire);
	}
}

float cEmpireColonizationManager::EmpireColonizationProbability(cEmpire* empire) {
	return std::min(1.0f,(targetNumSystems * cycleInterval) / (secondsToTargetNumSystems * 1000));
}

void cEmpireColonizationManager::EmpiresExpansionSubcycle() {
	for (int i = 0; i < empiresPerSubCycle; i++) {
		if (empireToExpand != empires.end() && EmpireUtils::ValidNpcEmpire(empireToExpand->get())) {
			float pOfExpansion = EmpireColonizationProbability(empireToExpand->get());
			float n = Math::randf();
			if (pOfExpansion > n) {
				ExpandEmpire(empireToExpand->get());
			}
			++empireToExpand;
		}
	}
}




