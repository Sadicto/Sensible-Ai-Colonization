#include "stdafx.h"
#include "cEmpireTerraformingManager.h"
#include "Spore-Mod-Utils/Include/SporeModUtils.h"
#include <algorithm>

using namespace Simulator;
using namespace SporeModUtils;

/// AUTOGENERATED METHODS ///

int cEmpireTerraformingManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireTerraformingManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireTerraformingManager::GetName() const {
	return "Ai_Empire_Expansion::cEmpireTerraformingManager";
}

bool cEmpireTerraformingManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireTerraformingManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cEmpireTerraformingManager::WriteToXML(XmlSerializer*)
{
	return true;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireTerraformingManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEmpireTerraformingManager* cEmpireTerraformingManager::instance = nullptr;

void cEmpireTerraformingManager::Initialize() {
	instance = this;

	ResourceKey terraformingConfigKey;

	ResourceKey terraformingSpeedConfigKey;

	ResourceKey radiusConfigKey;

	PropertyListPtr generalConfiguration;

	PropManager.GetPropertyList(id("Config"), id("SaicConfig"), generalConfiguration);

	// General configuration.
	App::Property::GetInt32(generalConfiguration.get(), 0xABC6D7D2, cycleInterval);

	App::Property::GetInt32(generalConfiguration.get(), 0x2FE6FD8A, levelToDecreaseAtmosphere);

	App::Property::GetInt32(generalConfiguration.get(), 0xE2138B62, levelToIncreaseAtmosphere);

	App::Property::GetInt32(generalConfiguration.get(), 0x0C8BE148, levelToDecreaseTemperature);

	App::Property::GetInt32(generalConfiguration.get(), 0xF3DA8410, levelToIncreaseTemperature);

	App::Property::GetKey(generalConfiguration.get(), 0x698512E7, terraformingConfigKey);

	App::Property::GetKey(generalConfiguration.get(), 0x84CF94F4, terraformingSpeedConfigKey);

	App::Property::GetKey(generalConfiguration.get(), 0x9732887C, radiusConfigKey);

	// Terraforming configuration.
	PropertyListPtr terraformingConfiguration;
	bool found = PropManager.GetPropertyList(terraformingConfigKey.instanceID, terraformingConfigKey.groupID, terraformingConfiguration);
	if (found) {
		App::Property::GetBool(terraformingConfiguration.get(), 0xF8ADEA45, terraformAllowed);
		App::Property::GetBool(terraformingConfiguration.get(), 0xFA3499E8, goodSpiceTerraformAllowed);
		App::Property::GetBool(terraformingConfiguration.get(), 0x1D71500A, badOrbitTerraformAllowed);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	// Terraforming speed configuration.
	PropertyListPtr terraformingSpeedConfiguration;
	found = PropManager.GetPropertyList(terraformingSpeedConfigKey.instanceID, terraformingSpeedConfigKey.groupID, terraformingSpeedConfiguration);
	if (found) {
		App::Property::GetFloat(terraformingSpeedConfiguration.get(), 0xF602D06C, terraformingPerHour);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	// Radius configuration.
	PropertyListPtr radiusConfiguration;
	found = PropManager.GetPropertyList(radiusConfigKey.instanceID, radiusConfigKey.groupID, radiusConfiguration);
	if (found) {
		App::Property::GetFloat(radiusConfiguration.get(), 0x0D00F9E5, activeRadius);
		App::Property::GetBool(radiusConfiguration.get(), 0x02FB896F, galacticRadius);
	}
	else {
		App::ConsolePrintF("A broken installation of SensibleAiColonization was detected, please reinstall the mod.");
	}

	elapsedTime = 0;
}

void cEmpireTerraformingManager::Dispose() {
	
}

void cEmpireTerraformingManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		// Start of a cycle.
		if (elapsedTime > cycleInterval) {
			empires.clear();
			if (galacticRadius) {
				EmpiresMap empiresMap = StarManager.GetEmpires();
				for (const auto& par : empiresMap) {
					if (EmpireUtils::ValidNpcEmpire(par.second.get())) {
						empires.push_back(par.second);
					}
				}
				subcycleStep = 100;
			}
			else {
				EmpireUtils::GetEmpiresInRadius(GetActiveStarRecord()->mPosition, activeRadius, empires);
				subcycleStep = 1000;
			}
			int numEmpires = empires.size();
			empireToTerraform = empires.begin();
			int numSubcycles = cycleInterval / subcycleStep;
			// Division rounding up.
			empiresPerSubCycle = (numEmpires + numSubcycles - 1) / (numSubcycles);
			lastSubcycleTime = 0;
			elapsedTime = 0;
		}
		// Start of a subcycle.
		if (elapsedTime > lastSubcycleTime + subcycleStep) {
			while (elapsedTime > lastSubcycleTime) {
				EmpiresTerraformingSubycle();
				lastSubcycleTime += subcycleStep;
			}
		}
	}
}

void cEmpireTerraformingManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		spiceCosts.clear();
		SpiceUtils::GetSpawnableSpiceBaseCosts(spiceCosts);
		// Randomizes the start of the first cycle to avoid being synchronized with the cycles of other managers.
		elapsedTime = Math::rand(cycleInterval / 2);
		lastSubcycleTime = 9999999;
		subcycleStep = 9999999;
	}
}

cEmpireTerraformingManager* cEmpireTerraformingManager::Get() {
	return instance;
}

bool cEmpireTerraformingManager::TerraformablePlanet(Simulator::cPlanetRecord* planet) {
	if (PlanetUtils::InteractablePlanet(planet) && planet->mType != PlanetType::T3) {
		bool playerNotInSystem = planet->GetStarRecord() != GetActiveStarRecord();
		if (badOrbitTerraformAllowed) {
			return playerNotInSystem;
		}
		else {
			SolarSystemOrbitTemperature orbit = PlanetUtils::GetPlanetOrbitTemperature(planet);
			bool greenOrbit = orbit == SolarSystemOrbitTemperature::Normal;
			return playerNotInSystem && (greenOrbit || (goodSpiceTerraformAllowed && !SpiceUtils::LowValueSpice(planet->mSpiceGen, spiceCosts)));
		}
	}
	return false;
}

bool cEmpireTerraformingManager::EmpireCanTerraformPlanet(Simulator::cEmpire* empire, Simulator::cPlanetRecord* planet) {
	if (TerraformablePlanet(planet)) {
		PlanetType targetTerrascore = static_cast<PlanetType>(static_cast<int>(planet->mType) + 1);
		TerraformingUtils::TerraformingObstacle terraformingObstable = TerraformingUtils::GetTerraformingObstacle(planet, targetTerrascore);
		int empireLevel = EmpireUtils::GetEmpireLevel(empire);
		int levelRequiredToTerraformPlanet = 0;

		switch (terraformingObstable) {
		case(TerraformingUtils::TerraformingObstacle::Cold): {
			levelRequiredToTerraformPlanet = levelToIncreaseTemperature;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::ColdHighAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToIncreaseTemperature, levelToDecreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::ColdLowAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToIncreaseTemperature, levelToIncreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HighAtmosphere): {
			levelRequiredToTerraformPlanet = levelToDecreaseAtmosphere;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::Hot): {
			levelRequiredToTerraformPlanet = levelToDecreaseTemperature;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HotHighAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToDecreaseTemperature, levelToDecreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HotLowAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToDecreaseTemperature, levelToIncreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::LowAtmosphere): {
			levelRequiredToTerraformPlanet = levelToIncreaseAtmosphere;
			break;
		}
		}
		return empireLevel >= levelRequiredToTerraformPlanet;
	}
	else {
		return false;
	}
}

float cEmpireTerraformingManager::EmpireTerraformingProbability(Simulator::cEmpire* empire) {
	float milisecondsInHour = 60 * 60 * 1000;
	return std::min(1.0f, (cycleInterval * terraformingPerHour) / milisecondsInHour);
}

float cEmpireTerraformingManager::GetTerraformingValue(Simulator::cPlanetRecord* planet) {
	float baseValue = 1;
	SolarSystemOrbitTemperature orbit = PlanetUtils::GetPlanetOrbitTemperature(planet);
	if (orbit == SolarSystemOrbitTemperature::Normal) {
		baseValue += 0.5f;
		if (planet->mType == PlanetType::T0) {
			baseValue += 0.1f;
		}
	}
	ResourceKey planetSpice = planet->mSpiceGen;
	ResourceKey cheapestSpice = SpiceUtils::GetCheapestSpice(spiceCosts);
	auto itPlanet = spiceCosts.find(planetSpice);
	if (itPlanet != spiceCosts.end()) {
		float planetSpiceValue = static_cast<float>(itPlanet->second);
		auto itCheapest = spiceCosts.find(cheapestSpice);
		if (itCheapest != spiceCosts.end()) {
			float cheapestSpiceValue = static_cast<float>(itCheapest->second);
			return baseValue + (planetSpiceValue / cheapestSpiceValue) - 1.0f;
		}
		else {
			// this should never happen.
			return 0;
		}
	}
	else {
		// this should never happen.
		return 0;
	}



}

Simulator::cPlanetRecord* cEmpireTerraformingManager::GetBestTerraformablePlanetForEmpire(Simulator::cEmpire* empire) {
	eastl::vector<cPlanetRecordPtr> empirePlanets;
	EmpireUtils::GetEmpirePlanets(empire, empirePlanets, spiceCosts, false, false, !(badOrbitTerraformAllowed || goodSpiceTerraformAllowed), (goodSpiceTerraformAllowed && !badOrbitTerraformAllowed));
	float maxTerraformingValue = 0.0f;
	cPlanetRecord* topTerraformingPlanet = nullptr;
	for (cPlanetRecordPtr planet : empirePlanets) {
		if (EmpireCanTerraformPlanet(empire, planet.get())) {
			float terraformingValue = GetTerraformingValue(planet.get());
			if (terraformingValue > maxTerraformingValue) {
				maxTerraformingValue = terraformingValue;
				topTerraformingPlanet = planet.get();
			}
		}
	}
	return topTerraformingPlanet;
}

void cEmpireTerraformingManager::EmpireTerraformPlanet(Simulator::cEmpire* empire) {
	cPlanetRecord* planetToTerraform = GetBestTerraformablePlanetForEmpire(empire);
	if (EmpireCanTerraformPlanet(empire, planetToTerraform)) {
		PlanetType targetTerrascore = static_cast<PlanetType>(static_cast<int>(planetToTerraform->mType) + 1);
		TerraformingUtils::TerraformToTerrascore(planetToTerraform, targetTerrascore);
	}
}

void cEmpireTerraformingManager::EmpiresTerraformingSubycle() {
	for (int i = 0; i < empiresPerSubCycle; i++) {
		if (empireToTerraform != empires.end() && EmpireUtils::ValidNpcEmpire(empireToTerraform->get())) {
			float pOfTerraforming = EmpireTerraformingProbability(empireToTerraform->get());
			float n = Math::randf();
			if (pOfTerraforming > n) {
				EmpireTerraformPlanet(empireToTerraform->get());
			}
			++empireToTerraform;
		}
	}
}