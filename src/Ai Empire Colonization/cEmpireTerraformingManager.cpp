#include "stdafx.h"
#include "cEmpireTerraformingManager.h"
using namespace Simulator;

/// AUTOGENERATED METHODS ///

int cEmpireTerraformingManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireTerraformingManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireTerraformingManager::GetName() const {
	return "Ai_Empire_Expansion::cEmpireTerraformingManager";
}

bool cEmpireTerraformingManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireTerraformingManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireTerraformingManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEmpireTerraformingManager* cEmpireTerraformingManager::instance = nullptr;

void cEmpireTerraformingManager::Initialize() {
	instance = this;
	terraformAllowed = true;
	goodSpiceTerraformAllowed = true;
	badOrbitTerraformAllowed = false;
	levelToDecreaseAtmosphere = 0;
	levelToIncreaseAtmosphere = 1;
	levelToDecreaseTemperature = 2;
	levelToIncreaseTemperature = 3;

	cycleInterval = 60000;

	elapsedTime = 0;

	terraformingPerHour = 4;
	
}

void cEmpireTerraformingManager::Dispose() {
	
}

void cEmpireTerraformingManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			//EmpiresTerraformingCycle();
			elapsedTime = 0;
		}
	}
}

void cEmpireTerraformingManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
}

cEmpireTerraformingManager* cEmpireTerraformingManager::Get() {
	return instance;
}