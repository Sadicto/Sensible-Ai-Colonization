#include "stdafx.h"
#include "cEmpireTerraformingManager.h"
#include "Spore-Mod-Utils/Include/SporeModUtils.h"
#include <algorithm>

using namespace Simulator;
using namespace SporeModUtils;

/// AUTOGENERATED METHODS ///

int cEmpireTerraformingManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireTerraformingManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireTerraformingManager::GetName() const {
	return "Ai_Empire_Expansion::cEmpireTerraformingManager";
}

bool cEmpireTerraformingManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireTerraformingManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cEmpireTerraformingManager::WriteToXML(XmlSerializer*)
{
	return true;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireTerraformingManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEmpireTerraformingManager* cEmpireTerraformingManager::instance = nullptr;

void cEmpireTerraformingManager::Initialize() {
	instance = this;
	terraformAllowed = true;
	goodSpiceTerraformAllowed = false;
	badOrbitTerraformAllowed = true;
	levelToDecreaseAtmosphere = 0;
	levelToIncreaseAtmosphere = 1;
	levelToDecreaseTemperature = 2;
	levelToIncreaseTemperature = 3;

	cycleInterval = 60000;

	elapsedTime = 0;

	terraformingPerHour = 4;
	
}

void cEmpireTerraformingManager::Dispose() {
	
}

void cEmpireTerraformingManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			//EmpiresTerraformingCycle();
			elapsedTime = 0;
		}
	}
}

void cEmpireTerraformingManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		spiceCosts.clear();
		SpiceUtils::GetSpawnableSpiceBaseCosts(spiceCosts);
		elapsedTime = 0;
	}
}

cEmpireTerraformingManager* cEmpireTerraformingManager::Get() {
	return instance;
}

bool cEmpireTerraformingManager::TerraformablePlanet(Simulator::cPlanetRecord* planet) {
	if (PlanetUtils::InteractablePlanet(planet) && planet->mType != PlanetType::T3) {
		if (badOrbitTerraformAllowed) {
			return true;
		}
		else {
			SolarSystemOrbitTemperature orbit = PlanetUtils::GetPlanetOrbitTemperature(planet);
			bool greenOrbit = orbit == SolarSystemOrbitTemperature::Normal;
			return (greenOrbit || (goodSpiceTerraformAllowed && !SpiceUtils::LowValueSpice(planet->mSpiceGen, spiceCosts)));
		}
	}
	return false;
}

bool cEmpireTerraformingManager::EmpireCanTerraformPlanet(Simulator::cEmpire* empire, Simulator::cPlanetRecord* planet) {
	if (TerraformablePlanet(planet)) {
		PlanetType targetTerraforming = static_cast<PlanetType>(static_cast<int>(planet->mType) + 1);
		TerraformingUtils::TerraformingObstacle terraformingObstable = TerraformingUtils::GetTerraformingObstacle(planet, targetTerraforming);
		int empireLevel = EmpireUtils::GetEmpireLevel(empire);
		int levelRequiredToTerraformPlanet = 0;

		switch (terraformingObstable) {
		case(TerraformingUtils::TerraformingObstacle::Cold): {
			levelRequiredToTerraformPlanet = levelToIncreaseTemperature;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::ColdHighAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToIncreaseTemperature, levelToDecreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::ColdLowAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToIncreaseTemperature, levelToIncreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HighAtmosphere): {
			levelRequiredToTerraformPlanet = levelToDecreaseAtmosphere;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::Hot): {
			levelRequiredToTerraformPlanet = levelToDecreaseTemperature;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HotHighAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToDecreaseTemperature, levelToDecreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HotLowAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToDecreaseTemperature, levelToIncreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::LowAtmosphere): {
			levelRequiredToTerraformPlanet = levelToIncreaseAtmosphere;
			break;
		}
		}
		return empireLevel >= levelRequiredToTerraformPlanet;
	}
	else {
		return false;
	}
}

float cEmpireTerraformingManager::EmpireTerraformingProbability(Simulator::cEmpire* empire) {
	float milisecondsInHour = 60 * 60 * 1000;
	return std::min(1.0f, cycleInterval / milisecondsInHour);
}