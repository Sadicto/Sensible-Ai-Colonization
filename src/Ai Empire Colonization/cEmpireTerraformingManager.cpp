#include "stdafx.h"
#include "cEmpireTerraformingManager.h"
#include "Spore-Mod-Utils/Include/SporeModUtils.h"
#include <algorithm>

using namespace Simulator;
using namespace SporeModUtils;

/// AUTOGENERATED METHODS ///

int cEmpireTerraformingManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireTerraformingManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireTerraformingManager::GetName() const {
	return "Ai_Empire_Expansion::cEmpireTerraformingManager";
}

bool cEmpireTerraformingManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireTerraformingManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cEmpireTerraformingManager::WriteToXML(XmlSerializer*)
{
	return true;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireTerraformingManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

cEmpireTerraformingManager* cEmpireTerraformingManager::instance = nullptr;

void cEmpireTerraformingManager::Initialize() {
	instance = this;
	terraformAllowed = true;
	goodSpiceTerraformAllowed = true;
	badOrbitTerraformAllowed = false;
	levelToDecreaseAtmosphere = 0;
	levelToIncreaseAtmosphere = 1;
	levelToDecreaseTemperature = 2;
	levelToIncreaseTemperature = 3;

	cycleInterval = 60000;

	elapsedTime = 0;

	terraformingPerHour = 4;
	
}

void cEmpireTerraformingManager::Dispose() {
	
}

void cEmpireTerraformingManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			EmpiresTerraformingCycle();
			elapsedTime = 0;
		}
	}
}

void cEmpireTerraformingManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		spiceCosts.clear();
		SpiceUtils::GetSpawnableSpiceBaseCosts(spiceCosts);
		elapsedTime = 0;
	}
}

cEmpireTerraformingManager* cEmpireTerraformingManager::Get() {
	return instance;
}

bool cEmpireTerraformingManager::TerraformablePlanet(Simulator::cPlanetRecord* planet) {
	if (PlanetUtils::InteractablePlanet(planet) && planet->mType != PlanetType::T3) {
		if (badOrbitTerraformAllowed) {
			return true;
		}
		else {
			bool playerNotInSystem =planet->GetStarRecord() != GetActiveStarRecord() ;
			SolarSystemOrbitTemperature orbit = PlanetUtils::GetPlanetOrbitTemperature(planet);
			bool greenOrbit = orbit == SolarSystemOrbitTemperature::Normal;
			return playerNotInSystem && (greenOrbit || (goodSpiceTerraformAllowed && !SpiceUtils::LowValueSpice(planet->mSpiceGen, spiceCosts)));
		}
	}
	return false;
}

bool cEmpireTerraformingManager::EmpireCanTerraformPlanet(Simulator::cEmpire* empire, Simulator::cPlanetRecord* planet) {
	if (TerraformablePlanet(planet)) {
		PlanetType targetTerrascore = static_cast<PlanetType>(static_cast<int>(planet->mType) + 1);
		TerraformingUtils::TerraformingObstacle terraformingObstable = TerraformingUtils::GetTerraformingObstacle(planet, targetTerrascore);
		int empireLevel = EmpireUtils::GetEmpireLevel(empire);
		int levelRequiredToTerraformPlanet = 0;

		switch (terraformingObstable) {
		case(TerraformingUtils::TerraformingObstacle::Cold): {
			levelRequiredToTerraformPlanet = levelToIncreaseTemperature;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::ColdHighAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToIncreaseTemperature, levelToDecreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::ColdLowAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToIncreaseTemperature, levelToIncreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HighAtmosphere): {
			levelRequiredToTerraformPlanet = levelToDecreaseAtmosphere;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::Hot): {
			levelRequiredToTerraformPlanet = levelToDecreaseTemperature;
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HotHighAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToDecreaseTemperature, levelToDecreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::HotLowAtmosphere): {
			levelRequiredToTerraformPlanet = std::max(levelToDecreaseTemperature, levelToIncreaseAtmosphere);
			break;
		}
		case(TerraformingUtils::TerraformingObstacle::LowAtmosphere): {
			levelRequiredToTerraformPlanet = levelToIncreaseAtmosphere;
			break;
		}
		}
		return empireLevel >= levelRequiredToTerraformPlanet;
	}
	else {
		return false;
	}
}

float cEmpireTerraformingManager::EmpireTerraformingProbability(Simulator::cEmpire* empire) {
	float milisecondsInHour = 60 * 60 * 1000;
	return std::min(1.0f, cycleInterval / milisecondsInHour);
}

int cEmpireTerraformingManager::GetTerraformingValue(Simulator::cPlanetRecord* planet) {
	int baseValue = 1000;
	SolarSystemOrbitTemperature orbit = PlanetUtils::GetPlanetOrbitTemperature(planet);
	if (orbit == SolarSystemOrbitTemperature::Normal) {
		baseValue = baseValue * 2 - 1;
	}
	ResourceKey planetSpice = planet->mSpiceGen;
	ResourceKey cheapestSpice = SpiceUtils::GetCheapestSpice(spiceCosts);
	auto itPlanet = spiceCosts.find(planetSpice);
	if (itPlanet != spiceCosts.end()) {
		int planetSpiceValue = itPlanet->second;
		auto itCheapest = spiceCosts.find(cheapestSpice);
		if (itCheapest != spiceCosts.end()) {
			int cheapestSpiceValue = itCheapest->second;
			return baseValue * ((planetSpiceValue + cheapestSpiceValue - 1) / cheapestSpiceValue); //division rounding up.
		}
		else {
			// this should never happen.
			return 0;
		}
	}
	else {
		return 0;
	}



}

Simulator::cPlanetRecord* cEmpireTerraformingManager::GetBestTerraformablePlanetForEmpire(Simulator::cEmpire* empire) {
	eastl::vector<cPlanetRecordPtr> empirePlanets;
	EmpireUtils::GetEmpirePlanets(empire, empirePlanets, spiceCosts, false, false, !badOrbitTerraformAllowed, !goodSpiceTerraformAllowed);
	int maxTerraformingValue = 0;
	cPlanetRecord* topTerraformingPlanet = nullptr;
	for (cPlanetRecordPtr planet : empirePlanets) {
		if (EmpireCanTerraformPlanet(empire, planet.get())) {
			int terraformingValue = GetTerraformingValue(planet.get());
			if (terraformingValue > maxTerraformingValue) {
				maxTerraformingValue = terraformingValue;
				topTerraformingPlanet = planet.get();
			}
		}
	}
	return topTerraformingPlanet;
}

void cEmpireTerraformingManager::EmpireTerraformPlanet(Simulator::cEmpire* empire) {
	cPlanetRecord* planetToTerraform = GetBestTerraformablePlanetForEmpire(empire);
	if (EmpireCanTerraformPlanet(empire, planetToTerraform)) {
		PlanetType targetTerrascore = static_cast<PlanetType>(static_cast<int>(planetToTerraform->mType) + 1);
		TerraformingUtils::TerraformToTerrascore(planetToTerraform, targetTerrascore);
	}
}

void cEmpireTerraformingManager::EmpiresTerraformingCycle() {
	// Only empires within activeRadius parsecs can terraform.
	eastl::vector <cEmpirePtr> nearEmpires;

	EmpireUtils::GetEmpiresInRadius(GetActiveStarRecord()->mPosition, activeRadius, nearEmpires);
	// For each nearby empire, calculate pOfTerraform and terraform a planet based on the probability.
	for (cEmpirePtr empire : nearEmpires) {
		float pOfTerraform = EmpireTerraformingProbability(empire.get());
		float n = Math::randf();
		if (pOfTerraform > n) {
			EmpireTerraformPlanet(empire.get());
		}
	}
}